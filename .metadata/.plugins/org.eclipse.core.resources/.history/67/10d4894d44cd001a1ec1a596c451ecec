package CounterUI;

import static org.junit.Assert.*; 

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import static org.mockito.Mockito.*;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import Counter.MarketProxy;

@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class CounterFrameGUITest {

	private CounterFrame instance; // instance to test

	@Mock
	private MarketProxy mock; // injects mocked resource
	
	private void setConnect(long employee, String password, String ret) throws Exception {
		when(mock.connect(employee, password)).thenReturn(ret);
	}
	
	private void setGetName(long item, String name) throws Exception {
		when(mock.getName(item)).thenReturn(name);
	}
	
	private void setGetPrice(long item, double price) throws Exception {
		when(mock.getPrice(item)).thenReturn(price);
	}
	
	private void setGetCustomer(long code, String res) throws Exception {
		when(mock.getCustomer(code)).thenReturn(res);
	}

	private void setStartTransaction(long customer, long employee) throws Exception {
		when(mock.startTransaction(customer, employee));
	}

	private void setBuy(long item, long quantity) throws Exception {
		when(mock.buy(item, quantity));
	}

	private void setEndTransaction() throws Exception {
		when(mock.endTransaction());
	}
	
	private void setAbortTransaction() throws Exception {
		when(mock.abortTransaction());
	}

	private void setDisconnect() throws Exception {
		when(mock.disconnect());
	}
	@Before
	public void setUp() throws Exception {
		// create instance
		this.instance = new CounterFrame(this.mock);
	}

	@Test
	public void test() {
		fail("Not yet implemented");
	}

}
